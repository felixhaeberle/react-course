NEXT-GEN JS

let & const:

- var: default
- highly encouraged to use let and const
- let: variable value
- const: constant values

arrow functions:

- normal function:
function myFunc (){}
- arrow function (keeps this state):
const myFunc = () => {}
const multiply = (number) => number * 2

exports & imports:

- export default person
- export const baseData = 10;
- export const clean = () => {}
- import person from './person.js'
- import { baseData } from 'utility.js'
- import { clean } from './utility.js'

classes:

class Human {
  constructor() {
    this.gender = "male";
  }
  printGender(){
    console.log(this.gender);
  }
}
class Person extends Human {
  constructor() {
    super();
    this.name = 'Felix';
    this.gender = "female"
  }
  printMyName(){
    console.log(this.name);
  }
}
const person = new Person();
person.printMyName();
person.printGender();

classes, properties and methods:

class Human {
  gender = "male";
  printGender = () => {
    console.log(this.gender);
  }
}
class Person extends Human {
  name = 'Felix';
  printMyName = () => {
    console.log(this.name);
  }
}
const person = new Person();
person.printMyName();
person.printGender();

spread & rest operator:

- spread : const Array [...oldArray, 1, 2], const newObject [...oldObject, newProp :5]
- rest : const filter = (...args) => {
  return args.filter( el => el === 1);
}

destructing:

- array:
const numbers = [1,2,3];
[num1, ,num3] = numbers;
console.log(num1, num3);
-object:
const person = {name: 'Max', age: 22, location: "Meersburg"}
{prop1, ,prop3} = person;
console.log(prop1, prop3);

reference and primitive types:

const number = 1;
const num2 = number; -> copy
console.log(num2)
- objects doesn't have this behavior
- instead object uses pointers to the value
- prevent with const newPerson = {...oldPerson};
